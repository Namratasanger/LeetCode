### 1318. [Minimum Flips to Make a OR b Equal to c](https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/)

**Level:** Medium

**Problem:**
Given 3 positives numbers `a`, `b` and `c`. Return the minimum flips required in some bits of `a` and `b` to make ( `a` OR `b` == `c` ). (bitwise OR operation).
Flip operation consists of change any single bit `1` to `0` or change the bit `0` to `1` in their binary representation.

**Solution:**

``` javascript
/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number}
 */



var minFlips = function(a, b, c) {

    function decimalToBinary(num){
    let binaryRepresentation = "";
    while(num != 0){
        binaryRepresentation = (num % 2).toString() + binaryRepresentation;
        num = Math.floor(num / 2);
    }
    return binaryRepresentation;
    }

    function loopLength(a,b,c){
        if(a>=b && a>=c){
            return a;
        }
        if(b>=a && b>=c){
            return b;
        }
        return c;
    }

    function appendString(string, stringLength){
        let newString = string;
        for (let i = 0; i < loop - stringLength; i++) {
            newString = "0" + newString;
        }
        return newString;
    }
    a = decimalToBinary(a);
    b = decimalToBinary(b);
    c = decimalToBinary(c);
    let flips = 0;
    loop = loopLength(a.length, b.length, c.length);
    
    // append 0's in a
    
    a = appendString(a, a.length);
    b = appendString(b, b.length);
    c = appendString(c, c.length);  
    
    for(let i = loop-1; i >= 0; i--){
        if((!parseInt(a[i]) && !parseInt(b[i]) && parseInt(c[i])) || (parseInt(a[i]) && !parseInt(b[i]) && !parseInt(c[i])) || (!parseInt(a[i]) && parseInt(b[i]) && !parseInt(c[i]))){
            flips++;
        }else if(parseInt(a[i]) && parseInt(b[i]) && !parseInt(c[i])){
            flips = flips + 2;
        }
    }
    return flips;
};
```
